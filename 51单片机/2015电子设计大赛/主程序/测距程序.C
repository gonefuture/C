/******************************************************************************/
/*  Name:  LCD12864(St7920/St7921)+超声波测距模块+STC89C52                    */
/*  HC-SR04 超声波测距模块 DEMO 程序									      */
/*  晶振：11.0592M                                                            */
/*  接线：模块TRIG接 P1.2  ECH0 接P1.1										  */
/*      RS(CS)    接  P3.3;	 											      */	   
/*      RW(SID)   接  P3.4;										              */
/*      E(SCLK)   接  P3.5;											          */
/*      PSB       接  GND 串行模式										      */
/******************************************************************************/
    #include   <AT89X51.H>
	#include   <intrins.h>	
//引脚定义
    sbit     RX    =  P1 ^ 1;
    sbit     TX    =  P1 ^ 2;
    sbit     CS    =  P3 ^ 3;	//片选 高电平有效 单片LCD使用时可固定高电平
    sbit     SID   =  P3 ^ 4;	//数据
    sbit     SCLK  =  P3 ^ 5;	//时钟
/*--------------------------------------*/
unsigned char data CLOCK[4]={0,0,0,0};
unsigned int temp;  
sbit DQ = P1^3;


//Function Definition　函数声明 
void Delay(int num);
void Init_DS18B20(void);
unsigned char ReadOneChar(void);
void WriteOneChar(unsigned char dat);
unsigned int ReadTemperature(void);
void clock_out(unsigned char dd);
unsigned char clock_in(void);
unsigned char read_clock(unsigned char ord);
void write_clock(unsigned char ord, unsigned char dd);
void Disp(void);
void id_case1_key(void);
void id_case2_key(void);
void Set_time(unsigned char sel,bit sel_1);
void Timer0_Init(void);
void Init_1302(void);
void Set_Bell(unsigned char sel, bit sel_1);
void Bell(void);
//12864
void Write_char(bit start, unsigned char ddata);
void Send_byte(unsigned char bbyte);
void Delaynms(unsigned int di);
void Lcd_init(void);
void Disp_img(unsigned char *img);
void LCD_Write_string(unsigned char X,unsigned char Y,unsigned char *s);
void LCD_set_xy( unsigned char x, unsigned char y );
unsigned char code num[]={"0123456789 :.-;"};
unsigned char code waves[]={"Time:"};
unsigned char code znwk[] ={"保护您的眼睛"};
unsigned char code CM[] =  {"距离:          M"};
unsigned char code wendu[] ={""};

sbit pe=P2^1;
sbit pl=P2^2;
sbit alarm = P2^3; 
//sbit L2=P3^7;
sbit L1=P3^6;
unsigned int  time=0;
         long S=0;
         bit  flag =0;
unsigned char disbuff[4]	   ={ 0,0,0,0,};
unsigned char code logo[]={  
/*--  调入了一幅图像：logo.bmp  -- */ 
/*--  宽度x高度=128x64 欢迎使用本产品LOGO --*/
/*--  调入了一幅图像：C:\Documents and Settings\lwd\桌面\新建文件夹\X.bmp  --*/
/*--  宽度x高度=128x64  --*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xE0,0x00,0x00,0x0C,0x00,0x00,0x40,0x70,0x00,0x00,0x00,0x80,0x00,
0x00,0x00,0x00,0xE0,0x00,0x00,0x1E,0x00,0x00,0x60,0x70,0x00,0x00,0x0F,0xE0,0x00,
0x00,0x00,0x01,0xC0,0x00,0x60,0x3C,0x00,0x00,0xE0,0x60,0x00,0x1F,0xFF,0xE0,0x00,
0x00,0x00,0x03,0x80,0x00,0x70,0x70,0x40,0x00,0xE0,0x7E,0x00,0x1F,0xE0,0xC0,0x00,
0x00,0x00,0x03,0x00,0x00,0x73,0xC3,0xF0,0x01,0xC3,0xFC,0x00,0x38,0xE1,0xC0,0x00,
0x00,0x03,0xC6,0x3C,0x00,0x33,0x9F,0xF0,0x03,0x8F,0xC0,0x00,0x30,0xC1,0xC0,0x00,
0x00,0x3F,0xEF,0xFE,0x00,0x03,0x1C,0xE0,0x07,0x01,0xCC,0x00,0x31,0xF1,0x80,0x00,
0x00,0x79,0xDF,0xBC,0x00,0x06,0x18,0xC0,0x0E,0x01,0xFE,0x00,0x77,0xF9,0x80,0x00,
0x00,0x01,0xB0,0x30,0x01,0xC6,0x19,0xC0,0x1E,0x7F,0xDE,0x00,0x6F,0x83,0x80,0x00,
0x00,0x23,0xAC,0x60,0x0F,0xE6,0xF1,0x80,0x3E,0x7B,0x38,0x00,0x61,0x83,0x00,0x00,

0x00,0x37,0x0E,0x00,0x0F,0xC7,0xB7,0x80,0xEC,0x63,0x30,0x00,0xE3,0x03,0x00,0x00,
0x00,0x3E,0x0E,0x00,0x01,0x8F,0x37,0x01,0xCC,0x6F,0xF0,0x00,0xC7,0xF7,0x00,0x00,
0x00,0x1E,0x0C,0x00,0x03,0x1E,0x66,0x03,0x0C,0x7F,0x00,0x01,0xFF,0xE6,0x00,0x00,
0x00,0x1E,0x1C,0x00,0x03,0x1C,0x60,0x02,0x19,0xAC,0x00,0x01,0x96,0x06,0x00,0x00,
0x00,0x3E,0x3E,0x00,0x03,0x18,0x60,0x00,0x19,0xFC,0x00,0x03,0x86,0x0E,0x00,0x00,
0x00,0x7E,0x36,0x00,0x03,0x00,0xC0,0x00,0x38,0x78,0x00,0x03,0x06,0x0C,0x00,0x00,
0x00,0xE6,0x67,0x00,0x03,0x00,0xC0,0x00,0x30,0x78,0x00,0x06,0x0C,0x0C,0x00,0x00,
0x01,0xC6,0xC3,0x80,0x7F,0xF0,0xC0,0x00,0x30,0xFE,0x00,0x0E,0x0C,0x1C,0x00,0x00,
0x03,0x81,0x83,0xC0,0x78,0xFF,0x80,0x00,0x61,0xCF,0x80,0x1C,0x08,0x18,0x00,0x00,
0x06,0x07,0x03,0xE0,0x00,0x1F,0xFF,0xE0,0x67,0x07,0xE0,0x38,0x18,0xF8,0x00,0x00,
0x08,0x0E,0x01,0xF8,0x00,0x07,0xFF,0x80,0xCE,0x03,0xF8,0x60,0x00,0x70,0x00,0x00,
0x00,0x18,0x01,0xF8,0x00,0x01,0xFC,0x00,0xC0,0x01,0xFC,0xC0,0x00,0x70,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x06,0x00,0x00,0x00,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x07,0x00,0x00,0x00,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x06,0x00,0x00,0x00,0x0C,0xE0,0x00,0x01,0xE0,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x0E,0x00,0x00,0x00,0x3F,0xE0,0x00,0xFF,0xF0,0x00,0x38,0x00,0xE0,0x00,
0x00,0x00,0x0C,0x00,0x00,0x0F,0xFF,0x80,0x00,0xF8,0xF0,0x00,0x38,0x00,0xE0,0x00,
0x00,0x00,0x0C,0xF0,0x00,0x0F,0xC7,0x00,0x00,0x60,0xE0,0x00,0x38,0x00,0xE0,0x00,
0x00,0x00,0x1F,0xF0,0x00,0x01,0x8E,0x00,0x00,0x60,0xC0,0x00,0x70,0x01,0xC0,0x00,
0x00,0x07,0xFF,0x80,0x00,0x01,0x8C,0x00,0x00,0xE1,0x80,0x00,0x70,0x01,0xC0,0x00,
0x00,0x07,0xF8,0x00,0x00,0x01,0x98,0x00,0x00,0xDF,0xC0,0x00,0x70,0x01,0xC0,0x00,
0x00,0x00,0x78,0x00,0x00,0x01,0xBF,0xE0,0x00,0xFF,0x00,0x00,0x60,0x01,0x80,0x00,
0x00,0x00,0xFC,0x00,0x00,0x7F,0xFF,0xE0,0x00,0xC0,0x00,0x00,0xE0,0x03,0x80,0x00,
0x00,0x01,0xFE,0x00,0x00,0x7F,0xF8,0x00,0x00,0x00,0x00,0x00,0xC0,0x03,0x00,0x00,
0x00,0x03,0xB7,0x00,0x00,0x60,0x00,0x00,0x00,0x00,0x3C,0x00,0xC0,0x03,0x00,0x00,
0x00,0x07,0x67,0x00,0x00,0x60,0x00,0x00,0x03,0x9F,0xFE,0x00,0x80,0x02,0x00,0x00,
0x00,0x0E,0x63,0x80,0x00,0xE0,0x00,0x01,0xFF,0xCF,0x1E,0x01,0x80,0x06,0x00,0x00,
0x00,0x1C,0xE1,0xE0,0x00,0xC0,0x00,0x00,0xE3,0x9C,0x38,0x01,0x80,0x06,0x00,0x00,
0x00,0x38,0xC1,0xF8,0x01,0xC0,0x00,0x00,0xC3,0x18,0x30,0x00,0x00,0x00,0x00,0x00,
0x00,0xE0,0xFC,0xFE,0x03,0x80,0x00,0x01,0xC7,0x18,0x60,0x00,0x00,0x00,0x00,0x00,
0x01,0xDF,0xF8,0xFE,0x03,0x00,0x00,0x01,0x8E,0x1B,0xE0,0x07,0x00,0x1C,0x00,0x00,
0x07,0x07,0x80,0x00,0x07,0x00,0x00,0x01,0xFF,0x3F,0xE0,0x07,0x00,0x1C,0x00,0x00,
0x0C,0x03,0x80,0x00,0x0E,0x00,0x00,0x01,0xF0,0x38,0x00,0x0F,0x00,0x3C,0x00,0x00,
0x00,0x03,0x00,0x00,0x1C,0x00,0x00,0x01,0x00,0x20,0x00,0x06,0x00,0x18,0x00,0x00,
0x00,0x03,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x03,0x00,0x00,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x02,0x00,0x01,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};

/******************************************************************************/
void Lcd_init(void)	//初始化LCD 
{
	Delaynms(10); //启动等待，等LCM讲入工作状态
  	CS=1;
  	Write_char(0,0x30);  //8 位介面，基本指令集
  	Write_char(0,0x0c);  //显示打开，光标关，反白关
  	Write_char(0,0x01);  //清屏，将DDRAM的地址计数器归零  
}

/******************************************************************************/
void Write_char(bit start, unsigned char ddata) //写指令或数据
{
	unsigned char start_data,Hdata,Ldata;
  	if(start==0) 
		start_data=0xf8;	 //写指令
    else    
    	start_data=0xfa;  //写数据
  
  	Hdata=ddata&0xf0;		  //取高四位
  	Ldata=(ddata<<4)&0xf0;  //取低四位
  	Send_byte(start_data);	  //发送起始信号
  	Delaynms(5); //延时是必须的
  	Send_byte(Hdata);	      //发送高四位
  	Delaynms(1);  //延时是必须的
  	Send_byte(Ldata);		  //发送低四位
  	Delaynms(1);  //延时是必须的
}

/******************************************************************************/
void Send_byte(unsigned char bbyte) //发送一个字节
{
	unsigned char i;
 	for(i=0;i<8;i++)
   	{
   		SID=bbyte&0x80; //取出最高位
 		SCLK=1;
   		SCLK=0;
   		bbyte<<=1; //左移
   	}  
}

/******************************************************************************/
void Delaynms(unsigned int di) //延时
{
	unsigned int da,db;
 	for(da=0;da<di;da++)
   		for(db=0;db<10;db++);
}

/******************************************************************************/
void Disp_img(unsigned char  *img)	//图形方式12864显示字模221 横向取膜
{ 
	unsigned char i,j;
	unsigned int k = 0;

	Write_char(0,0x36); //图形方式
	for(i=0;i<32;i++)
  	{ 
		Write_char(0,0x80+i);
		Write_char(0,0x80);
    	for(j=0;j<16;j++) 
		{
			Write_char(1,img[k++]);
		}
  	}

 	for(i=0;i<32;i++)
  	{ 
		Write_char(0,0x80+i);
		Write_char(0,0x88);
    	for(j=0;j<16;j++) 
		{
			Write_char(1,img[k++]);
  		}
	}
}
	
/******************************************************************************/
void Clr_Scr(void)//清屏函数
{
	Write_char(0,0x01);
}

/******************************************************************************/
void LCD_set_xy( unsigned char x, unsigned char y )
{	//设置LCD显示的起始位置，X为行，Y为列
    unsigned char address;
	switch(x)
	{
		case 0: address = 0x80 + y; break;    
    	case 1: address = 0x80 + y; break; 
		case 2: address = 0x90 + y; break; 
   	 	case 3: address = 0x88 + y; break;
		case 4: address = 0x98 + y; break; 
		default:address = 0x80 + y; break;
	}
    Write_char(0, address);
}

/******************************************************************************/
void LCD_Write_string(unsigned char X,unsigned char Y,unsigned char *s)
{	//	中英文字符串显示函数
	LCD_set_xy( X, Y );
    
    while (*s) 
    {
		Write_char( 1, *s );
	    s ++;
		Delaynms(1);
	}
}

/******************************************************************************/
void LCD_Write_number(unsigned char s)//	数字显示函数
{	
	Write_char(1,num[s]);
	Delaynms(1);
}
/******************************************************************************/
void Lcd_Mark2(void)
{
	Clr_Scr();//清屏
	LCD_Write_string(1,1,znwk);//
	LCD_Write_string(2,0,waves);//	
	LCD_Write_string(3,0,CM);//
	LCD_Write_string(4,0,wendu);

		
}


/********************************************************/
    void Conut(void)
	{
	   time=TH0*256+TL0;
	   TH0=0;
	   TL0=0;
	   S=time*1.87/100;       //算出来是CM	  11。0592M晶振
	   if(flag==1)		      //超出测量
	  {	 
	   flag=0;
	   LCD_set_xy( 3, 4 );
	   LCD_Write_number(13);
	   LCD_Write_number(12);
	   LCD_set_xy( 3, 5 );
	   LCD_Write_number(13);
	   LCD_Write_number(13);
	  
	   }
	 else
	  {
	   disbuff[1]=S%1000/100;
	   disbuff[2]=S%1000%100/10;
	   disbuff[3]=S%1000%10 %10;
	   LCD_set_xy( 3, 4 );
	   LCD_Write_number(disbuff[1]);
	   LCD_Write_number(12);
	   LCD_set_xy( 3, 5 );
	   LCD_Write_number(disbuff[2]);
	   LCD_Write_number(disbuff[3]);
	  }

	}
/********************************************************/ 
void delayms(unsigned int ms)
{
	unsigned char i=100,j;
	for(;ms;ms--)
	{
		while(--i)
		{
			j=10;
			while(--j);
		}
	}
}
/********************************************************/
     void zd0() interrupt 1 		 //T0中断用来计数器溢出,超过测距范围
  {
    flag=1;							 //中断溢出标志
  }
/********************************************************/
   void  StartModule() 		         //T1中断用来扫描数码管和计800MS启动模块
  {
	  TX=1;			                 //800MS  启动一次模块
	  _nop_(); 
	  _nop_(); 
	  _nop_(); 
	  _nop_(); 
	  _nop_(); 
	  _nop_(); 
	  _nop_(); 
	  _nop_(); 
	  _nop_(); 
	  _nop_(); 
	  _nop_(); 
	  _nop_(); 
	  _nop_(); 
	  _nop_(); 
	  _nop_(); 
	  _nop_(); 
	  _nop_();
	  _nop_(); 
	  _nop_(); 
	  _nop_(); 
	  _nop_();
	  TX=0;
  }

/*******************************************/

/*****************DS18B20******************/
	void Init_Ds18b20(void)     //DS18B20初始化send reset and initialization command
{
	DQ = 1;                     //DQ复位,不要也可行。
	Delaynms(1);                  //稍做延时
	DQ = 0;                    //单片机拉低总线
	Delaynms(250);                //精确延时，维持至少480us
	DQ = 1;                    //释放总线，即拉高了总线
	Delaynms(100);                //此处延时有足够,确保能让DS18B20发出存在脉冲。
}

	unsigned char Read_One_Byte()       //读取一个字节的数据read a byte date
	//读数据时,数据以字节的最低有效位先从总线移出
	{
	unsigned char i   = 0;
	unsigned char dat = 0;
	for(i=8;i>0;i--)
	{
	DQ = 0;                  //将总线拉低，要在1us之后释放总线
	//单片机要在此下降沿后的15us内读数据才会有效。
	_nop_();                 //至少维持了1us,表示读时序开始
	dat >>= 1;               //让从总线上读到的位数据，依次从高位移动到低位。
	DQ = 1;                  //释放总线，此后DS18B20会控制总线,把数据传输到总线上
	Delaynms(1);                 //延时7us,此处参照推荐的读时序图，尽量把控制器采样时间放到读时序后的15us内的最后部分
	if(DQ)                   //控制器进行采样
	{
	dat |= 0x80;            //若总线为1,即DQ为1,那就把dat的最高位置1;若为0,则不进行处理,保持为0
 }
 	Delaynms(10);               //此延时不能少，确保读时序的长度60us。
	}
	return (dat);
	}

	void Write_One_Byte(unsigned char dat)
	{
	unsigned char i = 0;
	for(i=8;i>0;i--)
	{
	DQ = 0;                        //拉低总线
	_nop_();                       //至少维持了1us,表示写时序(包括写0时序或写1时序)开始
	DQ = dat&0x01;                 //从字节的最低位开始传输
	//指令dat的最低位赋予给总线,必须在拉低总线后的15us内,
	//因为15us后DS18B20会对总线采样。
	Delaynms(10);                     //必须让写时序持续至少60us
	DQ = 1;                        //写完后,必须释放总线,
	dat >>= 1;
	Delaynms(1);
	}
}

	unsigned int Get_Tmp()                   //获取温度get the temperature
	{
	float tt;
	unsigned char a,b;
	Init_Ds18b20();                //初始化
	Write_One_Byte(0xcc);          //忽略ROM指令
	Write_One_Byte(0x44);          //温度转换指令
	Init_Ds18b20();                 //初始化
	Write_One_Byte(0xcc);          //忽略ROM指令
	Write_One_Byte(0xbe);          //读暂存器指令
	a = Read_One_Byte();           //读取到的第一个字节为温度LSB
	b = Read_One_Byte();           //读取到的第一个字节为温度MSB
	temp = b;                      //先把高八位有效数据赋于temp
	temp <<= 8;                    //把以上8位数据从temp低八位移到高八位
	temp = temp|a;                //两字节合成一个整型变量
	tt = temp*0.0625;              //得到真实十进制温度值
	//因为DS18B20可以精确到0.0625度
	//所以读回数据的最低位代表的是0.0625度
	temp = tt*10+0.5;               //放大十倍
	//这样做的目的将小数点后第一位也转换为可显示数字
	//同时进行一个四舍五入操作。
	return temp;
	}
/************************************************************/
void display(void)
{ 
unsigned char un[10];
/* unsigned char wen[2];
 un[0]=CLOCK[2]/10;//小时
 un[1]=CLOCK[2]%10;
 un[2]=':';
 un[3]=CLOCK[1]/10;//分钟
 un[4]=CLOCK[1]%10;
 un[5]=':';
 un[6]=CLOCK[0]/10;//秒钟
 un[7]=CLOCK[0]%10;

 wen[0]=Get_Tmp()%100/10;
 wen[1]=Get_Tmp()%10; */

 un[0]=CLOCK[3]/10;//小时
 un[1]=CLOCK[3]%10;
 un[2]=' ';
 un[3]=CLOCK[2]/10;//分钟
 un[4]=CLOCK[2]%10;
 un[5]=' ';
 un[6]=CLOCK[1]/10;//秒钟
 un[7]=CLOCK[1]%10;
 //un[8]=CLOCK[0]/10;//百分秒
// un[9]=CLOCK[0]%10;
   
	   LCD_set_xy( 2,3  );
	   LCD_Write_number(un[0]);
	   LCD_Write_number(un[1]);
	   LCD_Write_number(12);
	   LCD_Write_number(un[3]);
	   LCD_Write_number(un[4]);
	   LCD_Write_number(12);
	   LCD_Write_number(un[6]);	
	   LCD_Write_number(un[7]);
	  // LCD_set_xy( 4,5);
	  // LCD_Write_number(wen[0]);	
	   //LCD_Write_number(wen[1]);
	  // LCD_Write_string(1,0,znwk);
}
/******/
void timer1(void) interrupt 3
 
{
 TH1=(65536-50000)/256;TL1=(65536-50000)%256;//重装初值
 CLOCK[0]=CLOCK[0]+1;
 if(CLOCK[0]==20)
 {
  CLOCK[0]=0;
  CLOCK[1]+=1;
  if(CLOCK[1]==60)
  {
   CLOCK[1]=0;
   CLOCK[2]+=1;
   if(CLOCK[2]==60)
   {
    CLOCK[2]=0;
    CLOCK[3]+=1;
    if(CLOCK[3]==24)
    {CLOCK[3]=0;}
   }
  }
 }
}
/*******************************************************************/
/********************************************************/
void main(void)
{   
    TMOD=0x11; //设T1为方式1，GATE=1
	TH0=0xb6;
	TL0=0;
    TH1=(65536-50000)/256;
    TL1=(65536-50000)%256;
	EA=1; 
	ET1=1;
	TR0=1;
	TR1=1;

	Lcd_init();       //设置液晶显示器
	Clr_Scr();        //清屏	
	Disp_img(logo);	  //显示欢迎使用本产品LOGO
	Delaynms(1000);
	Lcd_init();       //从图形显示状态下返回
    Lcd_Mark2();
 

	while(1)
	{

	 StartModule();	 		        	//计算
	 while(!RX);		//当RX为零时等待
	 TR0=1;			    //开启计数
	 while(RX);			//当RX为1计数并等待
	 TR0=0;				//关闭计数
	 Conut();
	 	P2 =0x00;
	   if(S<=30||L1==1)
	   {
	   P2 =0x00;
       pe=1;
	   pl=1;
	   alarm =1;
	   }
	 delayms(80);		//80MS
/*	 CLOCK[0]+=1;
	  if(CLOCK[0]==60)
{ 
   CLOCK[0]=0;
   CLOCK[1]+=1;
   if(CLOCK[1]==60)
   {
    CLOCK[1]=0;
    CLOCK[2]+=1;
	if(CLOCK[2]==24)
		{CLOCK[2]=0; 
 
		}
   } 
}*/	 
	display();	
	 	 
	}

}              